PARSER_BEGIN(Parser)

package compiler;

import java.util.*;
import compiler.*;

public class Parser {

}

PARSER_END(Parser)


SKIP:  {
    <WS: " " | "\t" | "\r" | "\n" | "\r\n">
  | <SINGLE_LINE_COMMENT: "//" (~["\n","\r"])* ("\n"|"\r"|"\r\n")>
  | <MULTI_LINE_COMMENT: "/*"(~["/"])* "*/">
}
TOKEN: {
    <#LETTER: ["a"-"z", "A"-"Z", "_"]>
  | <#DIGIT: ["0"-"9"]>
}
TOKEN: {
    <INT_VALUE: (<DIGIT>)+>
  | <FLOAT_VALUE: <INT_VALUE> "." (<DIGIT>)* | "." (<DIGIT>)+>
  | <#ESCAPE: "\\" ["n","t","b","r","f","\\","\"","\'"]>
  | <CHAR_VALUE: "\'" (~["\'","\\"]|<ESCAPE>) "\'">
  | <STRING_VALUE: "\"" (~["\'","\\"]|<ESCAPE>)* "\"">
}
TOKEN: { /* KEYWORDS - обязательно описываем до <IDENT> */
    <IF: "if">
  | <ELSE: "else">
  | <FOR: "for">
  | <TRUE: "true">
  | <FALSE: "false">
}
TOKEN: {
    <IDENT: <LETTER>(<LETTER>|<DIGIT>)*>
}

ValueNode value(): { Token val; } {
    (
         val=<INT_VALUE>
       | val=<FLOAT_VALUE>
       | val=<STRING_VALUE>
       | val=<TRUE> | val=<FALSE>
    )
    { return new ValueNode(val.image); }
}

IdentNode ident(): { Token ident; } { ident=<IDENT> { return new IdentNode(ident.image); } }

List<ExprNode> params(): { List<ExprNode> params = new ArrayList<>(); ExprNode e; } {
    (e=expr() { params.add(e); } ("," e=expr() { params.add(e); })*)?
    { return params; }
}
FuncCallNode funcCall(): { IdentNode ident; List<ExprNode> params; } {
    ident=ident() "(" params=params() ")"
    { return new FuncCallNode(ident, params); }
}

ExprNode group(): { ExprNode e; } {
    (
        e=value()
      | LOOKAHEAD(2) e=funcCall()
      | e=ident()
      | "(" e=expr() ")"
    )
    { return e; }
}

ExprNode mult(): { ExprNode arg1; ExprNode arg2; Token op; } {
    arg1=group() ( ( op="*" | op="/" ) arg2=group() { arg1 = new BinaryOpNode(op.image, arg1, arg2); } )* { return arg1; }
}

ExprNode add(): { ExprNode arg1; ExprNode arg2; Token op; } {
    arg1=mult() ( ( op="+" | op="-" ) arg2=mult() { arg1 = new BinaryOpNode(op.image, arg1, arg2); } )* { return arg1; }
}

ExprNode expr(): { ExprNode r; } { r=add() { return r; } }

StmtNode stmt1(): { IdentNode ident; ExprNode expr; StmtNode stmt; } {
    (
        LOOKAHEAD(2) stmt=funcCall()
        | ident=ident() "=" expr=expr() { stmt = new AssignNode(ident, expr); }
    )
    { return stmt; }
}
StmtNode stmt2(): { StmtNode stmt; } {
    (
        "{" stmt=stmtList() "}"
      | { ExprNode cond; StmtNode thenStmt; StmtNode elseStmt = null; }
        <IF> "(" cond=expr() ")" thenStmt=stmt() (<ELSE> elseStmt=stmt())?
        { stmt = new IfNode(cond, thenStmt, elseStmt); }
    )
    { return stmt; }
}
StmtNode stmt(): { StmtNode stmt; } {
    ( stmt=stmt1() ";" | stmt=stmt2() )
    { return stmt; }
}

StmtNode stmtList(): { List<StmtNode> list = new ArrayList<>(); } {
    ( { StmtNode stmt; } stmt=stmt() { list.add(stmt); } )*
    { return new StmtListNode(list); }
}

StmtNode program(): { StmtNode program; } {
    program=stmtList() <EOF> { return program; }
}

AstNode start(): { StmtNode program; } {
    program=program() { return program; }
}
